// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: user_role.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createUserRole = `-- name: CreateUserRole :execresult
INSERT INTO userRoles (id,
                       userId,
                       roleId,
                       created,
                       updated)
VALUES (?,
        ?,
        ?,
        now(),
        now())
`

type CreateUserRoleParams struct {
	ID     string
	Userid string
	Roleid string
}

func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserRole, arg.ID, arg.Userid, arg.Roleid)
}

const findRoleByUserId = `-- name: FindRoleByUserId :many
SELECT id, userid, roleid, created, updated, deleted
FROM userRoles
WHERE userId = ?
`

func (q *Queries) FindRoleByUserId(ctx context.Context, userid string) ([]*Userrole, error) {
	rows, err := q.db.QueryContext(ctx, findRoleByUserId, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Userrole
	for rows.Next() {
		var i Userrole
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Roleid,
			&i.Created,
			&i.Updated,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE userRoles
SET userId  = ?,
    roleId  = ?,
    updated = now()
WHERE id = ?
`

type UpdateUserRoleParams struct {
	Userid string
	Roleid string
	ID     string
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserRole, arg.Userid, arg.Roleid, arg.ID)
	return err
}
